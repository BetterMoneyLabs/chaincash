# Basis Private (Chaumian E-Cash Style) - Proof of Concept

This document specifies a **privacy-enhanced variant** of the Basis off-chain cash system using Chaumian blind signature techniques. The goal is to provide **unlinkable bearer notes** while preserving the core Basis architecture of on-chain reserves and redemption enforcement.

---

## Threat Model and Privacy Goals

### Privacy Goals

1. **Unlinkability of Withdrawals and Redemptions**:
   - An observer (including the tracker and reserve) cannot link a withdrawal to a later redemption
   - Notes do not carry identifying information about the withdrawer

2. **Payment Unlinkability**:
   - When Alice pays Bob off-chain, the tracker cannot determine which withdrawal this note originated from
   - Multiple payments cannot be linked to the same original withdrawer

3. **Anonymity Set**:
   - Users are hidden within the anonymity set of all users withdrawing from the same reserve denomination
   - Larger denominations and more users increase privacy

### Non-Goals (Explicitly Out of Scope for PoC)

1. **Reserve Anonymity**: The reserve holder's identity remains public (R4 public key)
2. **Denomination Privacy**: Note denominations are public (different denominations = different anonymity sets)
3. **Timing Privacy**: Withdrawal and redemption timing is visible on-chain
4. **Network Privacy**: This spec does not address network-level privacy (use Tor/mixnets separately)
5. **Quantum Resistance**: Using classical Schnorr signatures (not post-quantum)

### Threat Model

**Honest-but-Curious Tracker**:
- Follows protocol correctly
- Attempts to link notes, de-anonymize users
- Cannot forge signatures but can analyze all data it sees

**Malicious Reserve Holder**:
- May collude with tracker
- Cannot forge blind signatures (signing key is secured)
- Cannot spend notes belonging to others (notes carry user signatures)

**External Blockchain Observer**:
- Monitors all on-chain transactions
- Attempts to link withdrawals to redemptions via timing, amounts, metadata
- Cannot see off-chain note transfers

**Our Defenses**:
- Blind signatures prevent linkage even if tracker and reserve collude
- Nullifiers prevent double-spending without revealing note identity
- Fixed denominations create anonymity sets
- Timing randomization and batching (future work) can reduce timing analysis

---

## Roles and Keys

### Reserve / Mint

**Role**: Issues blind-signed notes backed by on-chain ERG reserves

**Keys**:
- **Mint Signing Key** `sk_mint`: Secret key for blind-signing notes (secp256k1 scalar)
- **Mint Public Key** `PK_mint`: Corresponding public key (secp256k1 point), stored in reserve contract R4
- **Reserve NFT**: Singleton token identifying this reserve instance

**Operations**:
- Issues blind signatures over user-provided note commitments during withdrawals
- Does NOT learn the actual note serial numbers (blinded)
- Maintains on-chain reserve box with ERG backing

### Tracker

**Role**: Facilitates blind issuance and maintains spent-nullifier set

**Keys**:
- **Tracker Signing Key** `sk_tracker`: For authorizing note operations
- **Tracker Public Key** `PK_tracker`: Stored in tracker box R4
- **Tracker NFT**: Singleton token identifying the tracker (stored in reserve R6)

**State**:
- **Nullifier Set** `N`: Set of all spent note nullifiers (synchronized with on-chain R5)
- **Pending Issuances**: Temporary state during blind signing protocol

**Operations**:
- Coordinates blind signature issuance (may verify reserve has ERG before signing)
- Tracks which nullifiers have been spent
- Provides inclusion/exclusion proofs for nullifiers
- Publishes nullifier updates and events

### Users

**Role**: Withdraw, hold, transfer, and redeem private notes

**Keys**:
- **User Secret Key** `sk_user`: For spending notes (secp256k1 scalar)
- **User Public Key** `PK_user`: Corresponding public key
- **Ephemeral Blinding Factors** `r`: Per-note randomness for blinding

**Holdings**:
- Collection of private notes: `{(denomination, serial, blind_sig)}`
- Knows note preimages needed to compute nullifiers

**Operations**:
- Initiate blinded withdrawals from reserve
- Transfer notes to other users off-chain
- Redeem notes by revealing nullifiers on-chain

---

## Note Structure

A private Basis note is a tuple:

```
PrivateNote = (denom, serial, blind_sig)
```

### Fields

1. **`denom`** (Long): Denomination in nanoERG
   - Fixed values: e.g., 0.1 ERG, 1 ERG, 10 ERG
   - Public (not hidden) - different denominations = different anonymity sets
   - Reserve contract enforces only specific denominations

2. **`serial`** (32 bytes): Random serial number
   - Generated by user: `serial = RANDOM(32 bytes)`
   - Secret - never revealed in cleartext until redemption (via nullifier)
   - Uniquely identifies this note

3. **`blind_sig`** (GroupElement + BigInt): Blind Schnorr signature
   - Signature by mint over blinded note commitment
   - Structure: `(A', z')` where:
     - `A'`: Random point (GroupElement, 33 bytes)
     - `z'`: Response (scalare, 32 bytes)
   - Unblinded by user to obtain valid signature on `serial`

### Derived Values

**Note Commitment** (used internally during issuance):
```
note_commitment = hash(denom || serial)
```

**Nullifier** (revealed during redemption):
```
nullifier = hash("nullifier" || serial || PK_mint)
```
- Uniquely identifies a spent note
- Cannot be linked back to `serial` without knowledge of `serial`
- Binding to `PK_mint` prevents cross-reserve nullifier reuse

---

## Protocol Flows

### Flow 1: Withdraw (On-Chain Balance → Private Notes)

**Goal**: User converts on-chain ERG into blind-signed private notes

**Participants**: User, Reserve/Mint, Tracker

**Prerequisites**:
- Reserve box exists with available ERG ≥ `denom`
- User has ephemeral public key `PK_user` (can be freshly generated)

**Steps**:

1. **User generates note parameters**:
   ```
   serial = RANDOM(32 bytes)
   r = RANDOM_SCALAR()  // blinding factor
   note_commitment = hash(denom || serial)
   ```

2. **User blinds the commitment**:
   ```
   C_blind = note_commitment * G^r
   ```
   where `G` is the generator point.

3. **User sends blinded withdrawal request to Mint**:
   ```
   {denom, C_blind, deposit_tx_id}
   ```
   - `deposit_tx_id`: On-chain transaction sending `denom` ERG to reserve

4. **Mint verifies deposit**:
   - Checks `deposit_tx_id` sent `denom` ERG to reserve box
   - Verifies denomination is allowed
   - Ensures ERG not already claimed for withdrawal

5. **Mint creates blinded signature**:
   ```
   k = RANDOM_SCALAR()
   A = G^k
   e = hash(A || C_blind || PK_mint)
   z = k + e * sk_mint
   blind_sig = (A, z)
   ```

6. **Mint sends blind_sig to User**:
   ```
   {blind_sig = (A, z)}
   ```

7. **User unblinds the signature**:
   ```
   A' = A
   z' = z  // (in simplified scheme; full unblinding: z' = z + e*r)
   ```
   (Note: Exact unblinding depends on Schnorr blind signature variant. For this PoC, we use a simplified scheme where `(A, z)` is already the valid signature.)

8. **User stores private note**:
   ```
   PrivateNote = (denom, serial, (A', z'))
   ```

9. **Tracker updates state** (if involved):
   - Adds `deposit_tx_id` to processed deposits
   - Does NOT learn `serial` or `note_commitment` plaintext

**Privacy Property**: Mint signed `C_blind` without learning `note_commitment`. Later, when User reveals `nullifier`, Mint cannot link it back to this withdrawal.

---

### Flow 2: Pay (Off-Chain Transfer)

**Goal**: Alice transfers a private note to Bob off-chain

**Participants**: Alice (payer), Bob (payee)

**Prerequisites**:
- Alice holds `PrivateNote = (denom, serial, blind_sig)`
- Bob has provided a communication channel (e.g., NOSTR pubkey, encrypted messaging)

**Steps**:

1. **Alice selects note(s) to pay**:
   - Chooses notes totaling the desired payment amount
   - For simplicity, this PoC assumes exact denomination matching (no change)

2. **Alice sends note to Bob**:
   ```
   {denom, serial, blind_sig}
   ```
   - Sent via encrypted off-chain channel (e.g., NOSTR DM, Telegram)

3. **Bob verifies the note**:
   ```
   note_commitment = hash(denom || serial)
   e = hash(blind_sig.A || note_commitment || PK_mint)
   verify: G^(blind_sig.z) == blind_sig.A * PK_mint^e
   ```
   If verification passes, Bob accepts the note.

4. **Bob checks nullifier not spent**:
   ```
   nullifier = hash("nullifier" || serial || PK_mint)
   query Tracker: is nullifier in N?
   ```
   If `nullifier ∈ N`, note is already redeemed (double-spend attempt). Bob rejects.

5. **Bob stores the note**:
   - Bob now holds `PrivateNote = (denom, serial, blind_sig)`

**Privacy Property**:
- Tracker does NOT see this transfer (no on-chain transaction, no tracker involvement)
- Even if tracker later learns the nullifier (during redemption), it cannot link back to Alice or the original withdrawal
- Bob cannot determine who originally withdrew this note

**Change Handling** (future improvement):
- If Alice wants to pay `< denom`, she must redeem the note and re-withdraw smaller denominations
- Alternatively, implement a "split" protocol where Alice redeems and gets change notes (adds complexity)

---

### Flow 3: Redeem (Private Notes → On-Chain ERG)

**Goal**: User redeems a private note for ERG from the reserve

**Participants**: User, Reserve contract, Tracker

**Prerequisites**:
- User holds `PrivateNote = (denom, serial, blind_sig)`
- Reserve has ERG ≥ `denom`
- Nullifier not already spent

**Steps**:

1. **User computes nullifier**:
   ```
   nullifier = hash("nullifier" || serial || PK_mint)
   ```

2. **User checks nullifier not spent**:
   ```
   query Tracker: is nullifier in N?
   ```
   If yes, abort (note already redeemed).

3. **User generates redemption transaction**:

   **Inputs**:
   - Reserve box (spent to update R5 nullifier tree)

  **Data Inputs**:
   - Tracker box (for tracker signature verification)

   **Context Variables**:
   - `v0 = 0` (action: redemption)
   - `v1 = PK_user` (receiver public key)
   - `v2 = blind_sig (A', z')` (mint's signature on note)
   - `v3 = denom` (amount to redeem)
   - `v4 = serial` (note serial, revealed)
   - `v5 = AVL_insert_proof` (proof for inserting nullifier into R5)
   - `v6 = sig_tracker` (tracker authorizes redemption)

   **Outputs**:
   - Reserve box with:
     - Value reduced by `denom`
     - R5 AVL tree updated with `nullifier → timestamp`
   - Redemption output to `PK_user` with `denom` ERG

4. **Reserve contract validates** (ErgoScript):
   ```
   // Reconstruct note commitment
   note_commitment = hash(denom || serial)
   
   // Verify mint signature
   e = hash(A' || note_commitment || PK_mint)
   verify: G^(z') == A' * PK_mint^e
   
   // Compute nullifier
   nullifier = hash("nullifier" || serial || PK_mint)
   
   // Check nullifier not in R5 tree
   lookup R5.get(nullifier) -> None
   
   // Insert nullifier into R5
   R5.insert(nullifier -> timestamp) with proof v5
   
   // Verify tracker signature
   msg = nullifier || denom || timestamp
   verify_schnorr(sig_tracker, msg, PK_tracker)
   
   // Transfer denom ERG to PK_user output
   ```

5. **Transaction broadcast**:
   - User submits transaction to blockchain

6. **Tracker updates nullifier set**:
   - Observes new block, extracts nullifier from R5 tree update
   - Adds `nullifier` to in-memory set `N`
   - Publishes event: `{"event": "redemption", "nullifier": nullifier, "denom": denom}`

7. **User receives ERG**:
   - Redemption output is spendable by `PK_user`

**Double-Spend Prevention**:
- The nullifier is permanently recorded in R5 AVL tree
- Future redemption attempts with same nullifier fail at step `lookup R5.get(nullifier)`

**Privacy Properties**:
- Redemption reveals `nullifier` and `serial`, but NOT:
  - Original withdrawal transaction (blinded at issuance)
  - Previous holders (if note was transferred)
  - Other notes held by the same user
- Timing analysis: on-chain withdrawal and redemption timestamps are visible (mitigation: use batching/delays)

---

## Double-Spend Protection and Reserves

### On-Chain Reserve State

**Reserve Box Structure** (modified from current Basis):
- **Value**: ERG backing all issued notes
- **Token #0**: Reserve NFT (singleton)
- **R4**: `PK_mint` - Mint public key
- **R5**: AVL tree of nullifiers `nullifier → timestamp`
- **R6**: Tracker NFT ID

**Nullifier Tree**:
- **Key**: `nullifier` (32 bytes)
- **Value**: `timestamp` (8 bytes, milliseconds when nullified)
- **Flags**: Insert-only, no removal
- **Lookup**: `R5.get(nullifier)` returns `Some(timestamp)` if spent, `None` if unspent

### Tracker's Role in Reserve Tracking

**Tracker maintains**:
1. **Nullifier Set** `N`:
   - Synchronized with on-chain R5 tree
   - Fast membership queries for users checking note validity

2. **Pending Withdrawals Queue**:
   - Tracks on-chain deposits not yet blind-signed
   - Prevents double-issuance

3. **Reserve Balance Tracking**:
   - Monitors ERG in = deposits
   - Monitors ERG out = redemptions
   - Provides proof-of-reserves: `ERG_balance ≥ unspent_notes_value`

**Proof-of-Reserves**:
- Tracker publishes periodic commitments:
  ```
  {
    "reserve_box_id": "...",
    "erg_balance": 1000000000000,
    "issued_notes_count": 1000,
    "redeemed_notes_count": 300,
    "outstanding_value": 700 * 1_000_000_000,
    "fully_backed": true
  }
  ```
- Users can verify: `erg_balance ≥ outstanding_value`
- Tracker cannot forge this (on-chain reserve box is public)

### Redemption Rules

1. **Nullifier Uniqueness**: Each `nullifier` can only appear once in R5
2. **Signature Validity**: Mint's blind signature must verify against `note_commitment`
3. **Denomination Matching**: Redeemed amount must match note's `denom`
4. **Sufficient Reserve**: Reserve box must have ERG ≥ `denom`
5. **Tracker Authorization**: Tracker signature required (or 7-day timeout for emergency)

### Emergency Redemption (Tracker Offline)

If tracker disappears:
- After 7 days from note issuance, users can redeem without `sig_tracker`
- Contract checks: `current_timestamp - note_timestamp > 7 days`
- This prevents tracker censorship but reduces real-time double-spend protection

---

## Privacy Properties

### What is Hidden

1. **Withdrawal-Redemption Unlinkability**:
   - Mint sees blinded `C_blind` during withdrawal
   - Mint sees `nullifier` during redemption
   - Cannot link `C_blind` ↔ `nullifier` (cryptographic unlinkability via blinding)

2. **Inter-Payment Unlinkability**:
   - Tracker does not see off-chain transfers
   - Notes are bearer instruments - no identity attached
   - Tracker cannot determine payment graph between users

3. **User Anonymity**:
   - Users withdraw with fresh `PK_user` (can be rotated)
   - Redemption reveals a public key but not real-world identity
   - Users are hidden in anonymity set of all users of same denomination

4. **Amount Privacy (within denomination)**:
   - Observers know denomination (e.g., 1 ERG) but not exact number of notes held
   - Multiple small notes vs. one large note are indistinguishable at note level

### What Remains Visible

1. **Denominations**:
   - Notes have fixed, public denominations (0.1 ERG, 1 ERG, etc.)
   - Different denominations = different anonymity sets
   - Observers can see distribution of denomination usage

2. **On-Chain Timing**:
   - Withdrawal timestamp (when ERG deposited to reserve)
   - Redemption timestamp (when nullifier revealed)
   - Timing correlation attacks possible (mitigation: batching, random delays)

3. **Reserve Identity**:
   - Reserve holder's `PK_mint` is public
   - All notes from same reserve are linkable to that reserve
   - Cross-reserve anonymity sets do not mix

4. **Transaction Graph (On-Chain)**:
   - Deposit transactions to reserve are public
   - Redemption outputs are public
   - Observers can analyze on-chain flows (not off-chain transfers)

5. **Tracker Metadata**:
   - Tracker sees:
     - Total number of withdrawals (blinded)
     - Total number of redemptions (nullifiers)
     - Cannot link specific withdrawal to specific redemption
     - Can perform statistical analysis (e.g., surge in redemptions)

6. **Nullifier Reveal** (during redemption):
   - Nullifier permanently on-chain
   - If user redeems multiple notes in same transaction, linked by transaction ID
   - Recommendation: redeem one note per transaction

### Limitations and Deanonymization Vectors

1. **Timing Analysis**:
   - If only one withdrawal and one redemption happen in a time window, likely linked
   - Mitigation: Encourage batching, use mixing periods

2. **Amount Fingerprinting**:
   - Unique combination of denominations can create fingerprint
   - Example: withdrawing 1 ERG + 0.3 ERG + 0.07 ERG is unusual
   - Mitigation: Use standard denomination sets, avoid unique combos

3. **Network-Level Tracking**:
   - IP addresses during withdrawal/redemption can be logged
   - Mitigation: Use Tor, VPN, or mixnets

4. **Tracker-Mint Collusion**:
   - If tracker and mint collude with network observer, they might correlate:
     - Withdrawal IP + timing → Redemption IP + timing
   - Blind signatures still prevent cryptographic linkage
   - Mitigation: Separate network identities, use delays

5. **Small Anonymity Sets**:
   - If only a few users use a denomination, privacy degrades
   - Mitigation: Promote popular denominations, aggregate usage

6. **Side-Channel Attacks**:
   - Implementation flaws (e.g., timing attacks on signature verification)
   - Mitigation: Use constant-time crypto libraries

7. **Change and Splitting**:
   - This PoC does not support change (pay exact denominations only)
   - Needing to redeem for change creates on-chain trail
   - Future: Implement split protocol with blinded change notes

---

## Comparison to Current Transparent Basis

| Property | Transparent Basis | Private Chaumian Basis |
|----------|-------------------|------------------------|
| **Note Linkage** | Fully linked (`hash(AB)`) | Unlinkable (blind sigs) |
| **User Identity** | Public keys visible | Pseudonymous, rotatable |
| **Tracker Sees** | All debts, all parties | Blinded withdrawals, nullifiers only |
| **Transfer Privacy** | None (bilateral debts) | Off-chain, invisible to tracker |
| **Redemption Privacy** | Linked to debtor | Unlinkable to original withdrawal |
| **On-Chain Footprint** | `hash(AB)` relationships | Nullifiers (random-looking) |
| **Anonymity Set** | None | All users of same denomination |
| **Use Cases** | Auditable credit, community trust | Anonymous payments, private commerce |

---

## Implementation Notes for PoC

### Simplifications for Proof of Concept

1. **Single Denomination**: PoC uses one denomination (e.g., 1 ERG) to simplify
2. **No Change**: Exact denomination matching only - no split/merge
3. **Simplified Blind Schnorr**: May use a textbook Schnorr blind signature (not production-hardened)
4. **Tracker Centralized**: Single trusted tracker (future: federated or decentralized)
5. **No Timing Obfuscation**: No built-in delays or batching
6. **Placeholder Crypto**: Rust implementation may mock advanced cryptography for PoC

### Security Caveats

- **This is a PROOF OF CONCEPT**, not production-ready
- Cryptographic implementation should undergo audit
- Blind signature scheme must be proven secure (e.g., use ROS-resistant variants)
- Nullifier construction must prevent malleability
- AVL tree implementation must be insert-only and tamper-proof

---

## Future Extensions

1. **Multiple Denominations**: 0.1, 1, 10, 100 ERG notes
2. **Change Protocol**: Blind re-issuance for change during payments
3. **Federated Trackers**: Multiple trackers with threshold signatures
4. **Recursive Blinding**: Periodic re-blinding to refresh anonymity sets
5. **Cross-Reserve Swaps**: Atomic swaps between reserves to mix anonymity sets
6. **Zero-Knowledge Redemptions**: Use ZK-SNARKs to hide nullifier reveal
7. **Timing Obfuscation**: Scheduled batch withdrawals and redemptions
8. **Multi-Asset Support**: Private notes for tokens, not just ERG

---

## Summary

This Chaumian private Basis scheme transforms the transparent off-chain credit system into a privacy-preserving bearer cash system. By using blind signatures, users gain unlinkability between withdrawals and redemptions, while the on-chain reserve and nullifier-based double-spend prevention maintain security. The system preserves Basis's core innovation of on-chain reserves backing off-chain notes but adds a critical privacy layer suitable for anonymous micropayments, confidential commerce, and agent-to-agent value transfer.

**Key Innovation**: Blind signatures break the linkage between note issuance and redemption, providing privacy without trusted hardware or heavy zero-knowledge proofs, while maintaining compatibility with the Ergo blockchain's UTXO model and AVL trees.
